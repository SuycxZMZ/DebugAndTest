## 内存管理

### 1. new, delete. malloc, free

1. malloc和free是c语言的库函数，new和delete是c++的库函数，并非系统调用

2. 对于malloc在内存分配时:
    1. 如果要malloc的空间小于128K，malloc会先在内存池中分配，如果内存池中没有足够空间，则调用brk()系统调用，向进程堆空间申请内存。
    2. 如果申请的内存大于128K，则会调用mmap()系统调用，向操作系统申请内存。
    3. 在内存池或程序堆空间分配的内存已经是完全分配好的物理内存，可以直接使用，但是没有进行初始化。
    4. 调用mmap()申请的内存是在操作系统虚拟地址空间中分配的，不一定已经完全分配了物理内存，使用时如果没分配会触发缺页中断来分配。
3. 对于new在内存分配时:
    1. 调用operator new 分配一块内存空间，C++对operator new只规定了接口，其内部默认实现与编译器有关，开发者也可以重载。
    2. 调用placement new 在上一步申请的空间上调用类的默认构造函数初始化对象，所以在试使用C++的new操作符时，分配的内存一定是可以直接使用的物理内存，且已经被初始化完成。
4. 在释放内存时:
    1. free只接受对应malloc返回的指针，malloc会多分配出一小块固定大小内存，放置在内存块前面用于记录分配的内存信息。在调用free释放时，会先对穿进来的指针向前偏移到这个内存块起始处，拿到分配的这一块内存的所有信息进行释放。
    2. delete时，要注意new出来的数组要调用 delete[]释放否则会内存泄露。delete先执行析构函数，再释放内存。

### 2. 内存泄露

1. 内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
   
1. 常见原因:
    1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数。
    2. 没有正确地清除嵌套的对象指针。
    3. 在释放对象数组时在delete中没有使用方括号：方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。
    4. 指向对象的指针数组不等同于对象数组：对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间。指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。
    5. 缺少拷贝构造函数：两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。按值传递会调用（拷贝）构造函数，引用传递不会调用。在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符
    6. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针
    7. 没有将基类的析构函数定义为虚函数：当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露
    8.  野指针：指向被释放的或者访问受限内存的指针。造成野指针的原因：指针变量没有被初始化（如果值不定，可以初始化为NULL）。指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL。指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。
    9.  shared_ptr循环引用导致内存泄漏，用weak_ptr解决。
   
2. 避免内存泄漏的常用手段：
    1. 避免使用裸指针，使用智能指针。
    2. 静态代码检查工具
    3. valgrind工具
    4. GDB调试
